# Make命令与Makefile书写的学习

我的[学习资料](https://seisman.github.io/how-to-write-makefile/)

[TOC]

## 1).makefile介绍

#### a).Makefile的书写格式及示例

![image-20241121205018526](E:/PicGo/image-20241121205018526.png)

一个编写示例：

![image-20241121205136724](E:/PicGo/image-20241121205136724.png)

在该目录下直接输入命令 `make` 就可以生成执行文件edit。

反斜杠（ `\` ）是换行符的意思。

后续的recipe行定义了如何生成目标文件的操作系统命令，**一定要以一个 `Tab` 键作为开头。**

其中的clean像C语言中的label一样，其冒号后什么也没有，我将其视为make执行的**命令名**。

#### b).Make的工作方式

1. make在当前目录下找名字叫“Makefile”的文件。
2. 如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个文件，并把这个文件作为最终的目标文件。
3. 如果edit文件不存在，或是edit所依赖的后面的 `.o` 文件的文件修改时间要比 `edit` 这个文件新，那么，他就会执行后面所定义的命令来生成 `edit` 这个文件。
4. 如果 `edit` 所依赖的 `.o` 文件也不存在，那么make会在当前文件中找目标为 `.o` 文件的依赖性，如果找到则再根据那一个规则生成 `.o` 文件。
5. 由于你的C文件和头文件存在，于是make会生成 `.o` 文件，然后再用 `.o` 文件生成make的终极任务，也就是可执行文件 `edit` 。

###### 关于make的依赖性

make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错；而对于所定义的命令的错误，或是编译不成功，make根本不理。make只管文件的依赖性，即，如果在make找了依赖关系之后，冒号后面的文件还是不在，那么make便不会工作。像clean这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要make执行。即命令—— `make clean` ，以此来清除所有的目标文件，以便重编译。

#### c).makefile中使用变量

***makefile的变量也就是一个字符串，理解成C语言中的""宏""可能会更好。***

###### 我们为什么要使用变量？

若makefile并不复杂，在edit与clean中添加新的.o文件也不累；但如果makefile变得复杂，那么我们就有可能会忘掉一个需要加入的地方，而导致编译失败。**所以，为了makefile的易维护，在makefile中我们可以使用变量。**

![image-20241121213209279](E:/PicGo/image-20241121213209279.png)

**("target"换变量名，:变=)**

**引入变量后的makefile示例**：$(         )

![image-20241121213459977](E:/PicGo/image-20241121213459977.png)

#### d).让make自动推导

make很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个 `.o` 文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。

![image-20241121224000251](E:/PicGo/image-20241121224000251.png)

(去除了所有的**file.c**)

另一种风格：（简化）

![image-20241122182139224](E:/PicGo/image-20241122182139224.png)

#### e).清空目录的规则（clean命令）

***删.o别写成.c!***

![image-20241122182236820](E:/PicGo/image-20241122182236820.png)

## 2).makefile里面有什么？

#### a).Makefile里主要包含了五个东西：**显式规则、隐式规则、变量定义、指令和注释**。

1. **显式规则**。显式规则说明了如何生成一个或多个目标文件。这是由Makefile的书写者明显指出要生成的文件、文件的依赖文件和生成的命令。
2. **隐式规则**。由于我们的make有自动推导的功能，所以隐式规则可以让我们比较简略地书写Makefile，这是由make所支持的。
3. **变量的定义**。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点像你C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。
4. **指令**。其包括了三个部分，**一**是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；**二**是指根据某些情况指定Makefile中的有效部分，类似C语言中的预编译#if一样；**三**是定义一个多行的命令。
5. **注释**。Makefile中**只有行注释**，和UNIX的Shell脚本一样，***其注释是用 `#` 字符***，这个就像C中的 `//` 。如果你要在你的Makefile中使用 `#` 字符，可以用反斜杠进行转义，如： `\#` 。

#### b).makefile的相互包含

Makefile使用 `include` 指令可以把别的Makefile包含进来**（类似于C语言的#include用法）**

![image-20241122182653823](E:/PicGo/image-20241122182653823.png)

**-include <filenames>...**   表示无论include过程中出现什么错误，都不要报错继续执行。

## *3).make的工作方式(拖延战术)

阶段一：

1.读入所有的Makefile。

2.读入被include的其它Makefile。

3.初始化文件中的变量。

4.推导隐式规则，并分析所有规则。

5.为所有的目标文件创建依赖关系链。

阶段二:

6.根据依赖关系，决定哪些目标要重新生成。

7.执行生成命令。

## 4).书写规则

（***规则的顺序非常重要，一定要让make知道最终目标是什么！！***）

#### a).举例

![image-20241122184711034](E:/PicGo/image-20241122184711034.png)

#### b).语法

![image-20241122185140606](E:/PicGo/image-20241122185140606.png)

#### c).通配符的使用

如果我们想定义一系列比较类似的文件，我们可以使用通配符。**make支持三个通配符： `*` ， `?` 和 `~` 。**

波浪号（ `~` ）字符表示当前用户的 `$HOME` 目录。

星号（ `*` ）代替了你一系列的文件，如 `*.c` 表示所有后缀为c的文件。

![image-20241122185712419](E:/PicGo/image-20241122185712419.png)

通配符同样可以用在**变量（类似C中的宏）**中。

#### d).文件搜寻

make只会在当前的目录中去找寻依赖文件和目标文件

![image-20241122190331619](E:/PicGo/image-20241122190331619.png)

![image-20241122190529221](E:/PicGo/image-20241122190529221.png)

字符 `%` 的意思是匹配零或若干字符，（需引用 `%` ，使用 `\` ）例如， `%.h` 表示所有以 `.h` 结尾的文件。

#### e).伪目标(我视为命令名)与多目标

使用一个特殊的标记“.PHONY”来显式地指明一个目标是“伪目标”

![image-20241122190842329](E:/PicGo/image-20241122190842329.png)

特殊用法:

![image-20241122191002114](E:/PicGo/image-20241122191002114.png)

伪目标也可以成为依赖.

------

*使用多目标时,用变量表示着目前规则中所有的目标的集合

eg:![image-20241122191343057](E:/PicGo/image-20241122191343057.png)

 `-$(subst output,,$@)` 中的 `$` 表示执行一个Makefile的函数，函数名为subst，后面的为参数。关于函数，将在后面讲述。这里的这个函数是替换字符串的意思， `$@` 表示目标的集合，就像一个数组， `$@` 依次取出目标，并执于命令.

#### f).自动生成依赖性

如果我们的main.c中有一句 `#include "defs.h"` ，那么我们的依赖关系应该是：

```
main.o : main.c defs.h
```

如果我们执行下面的命令:

```
cc -M main.c
```

其输出是：

```
main.o : main.c defs.h
```

如果使用GNU的C/C++编译器，你得**用 `-MM` 参数**

## 5).书写命令

#### a).命令显示

用 `@` 字符在命令行前，这个命令将不被make显示出来,我们用这个功能来向屏幕显示一些信息:

```
@echo 正在编译XXX模块......
```

当make执行时，会输出“正在编译XXX模块……”字串，但不会输出命令，如果没有“@”，那么，make将输出:

```
echo 正在编译XXX模块......
正在编译XXX模块......
```

如果make执行时，带入make参数 `-n` 或 `--just-print` ，那么其**只是显示命令，但不会执行命令**.

make参数 `-s` 或 `--silent` 或 `--quiet` 则是**全面禁止命令**的显示.

#### b).命令执行

如果要让上一条命令的结果应用在下一条命令时，你应该**使用分号分隔这两条命令**。比如你的第一条命令是cd命令，你希望第二条命令得在cd之后的基础上运行，那么你就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。如：

![image-20241122192726505](E:/PicGo/image-20241122192726505.png)

#### c).命令出错

如果一个规则中的某个命令出错了（命令退出码非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行.

忽略命令的出错，我们可以在Makefile的命令行前加一个减号 `-` （在Tab键之后），标记为不管命令出不出错都认为是成功的。eg：

```
clean:
    -rm -f *.o
```

或者给make加上 `-i` 或是 `--ignore-errors` 参数,

当make的参数的是 `-k` 或是 `--keep-going` ，如果某规则中的命令出错了，那么就**终止该规则的执行，但继续执行其它规则**。

#### d).嵌套执行

```
export variable = value
```

其等价于：

```
variable = value
export variable
```

其等价于：

```
export variable := value
```

其等价于：

```
variable := value
export variable
```

如果你要传递所有的变量，那么，**只要一个export就行了**。后面什么也不用跟，表示传递所有的变量。

但是, `SHELL` 和`MAKEFLAGS` ，这两个变量不管你是否export，其总是要传递到下层 Makefile中

#### e).命令包

## 命令包

如果Makefile中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以 `define` 开始，以 `endef` 结束，如:

```
define run-yacc
yacc $(firstword $^)
mv y.tab.c $@
endef
```

这里，“run-yacc”是这个命令包的名字，其不要和Makefile中的变量重名。在 `define` 和 `endef` 中的两行就是命令序列。这个命令包中的第一个命令是运行Yacc程序，因为Yacc程序总是生成“y.tab.c”的文件，所以第二行的命令就是把这个文件改改名字。

```
foo.c : foo.y
    $(run-yacc)
```

我们可以看见，要使用这个命令包，我们就好像使用变量一样。

## 6).变量

#### a).命名规则

变量的命名字可以包含字符、数字，下划线（可以是数字开头），但不应该含有 `:` 、 `#` 、 `=` 或是空字符（空格、回车等）。

有一些变量是很奇怪字串，如 `$<` 、 `$@` 等，这些是自动化变量.

#### b).基础用法

变量在声明时需要给予初值，而在使用时，需要给在变量名前加上 `$` 符号，但最好用小括号 `()` 或是大括号 `{}` 把变量给包括起来。

变量可以使用在许多地方，如规则中的“目标”、“依赖”、“命令”以及新的变量中。

eg：

```
objects = program.o foo.o utils.o
program : $(objects)
    cc -o program $(objects)

$(objects) : defs.h
```

变量可以进行套用,即**变量中的变量**(嵌套).

#### c).高级用法

**变量值的替换:**

我们可以替换变量中的共有的部分，其格式是 `$(var:a=b)`  ，把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串。这里的“结尾”意思是“空格”或是“结束符”。

eg：

```
foo := a.o b.o c.o
bar := $(foo:.o=.c)
```

我们先定义了一个 `$(foo)` 变量，而第二行的意思是把 `$(foo)` 中所有以 `.o` 字串“结尾”全部替换成 `.c` ，所以我们的 `$(bar)` 的值就是“a.c b.c c.c”。

**“把变量的值再当成变量”:**

```
x = y
y = z
a := $($(x))
```

在这个例子中，$(x)的值是“y”，所以$($(x))就是$(y)，于是$(a)的值就是“z”。（注意，是“x=y”，而不是“x=$(y)”）

```
ifdef do_sort
    func := sort
else
    func := strip
endif

bar := a d b g q c

foo := $($(func) $(bar))
```

这个示例中，如果定义了“do_sort”，那么： `foo := $(sort a d b g q c)` ，于是 `$(foo)` 的值就是 “a b c d g q”，而如果没有定义“do_sort”，那么： `foo := $(strip a d b g q c)` ，调用的就是strip函数。

#### d).追加变量值

我们可以使用 `+=` 操作符给变量追加值，如：

```
objects = main.o foo.o bar.o utils.o
objects += another.o
```

于是，我们的 `$(objects)` 值变成：“main.o foo.o bar.o utils.o another.o”（another.o被追加进去了）

#### e).多行变量

使用**define关键字**。使用define关键字设置变量的值可以有换行，这有利于定义一系列的命令（。

define指令后面跟的是变量的名字，而重起一行定义变量的值，定义是以endef 关键字结束。其工作方式和“=”操作符一样。变量的值可以包含函数、命令、文字，或是其它变量。因为命令需要以[Tab]键开头，所以如果你用define定义的命令变量中没有以 `Tab` 键开头，那么make 就不会把其认为是命令。

下面的这个示例展示了define的用法:

```
define two-lines
echo foo
echo $(bar)
endef
```

#### f).模式变量

make的“模式”一般是至少含有一个 `%` 的，所以，我们可以以如下方式给所有以 `.o` 结尾的目标定义目标变量：

```
%.o : CFLAGS = -O
```

同样，模式变量的语法和“目标变量”一样：

```
<pattern ...>; : <variable-assignment>;

<pattern ...>; : override <variable-assignment>;
```

## 7).使用条件判断

#### a).示例

下面的例子，判断 `$(CC)` 变量是否 `gcc` ，如果是则使用GNU函数编译目标。

```
libs_for_gcc = -lgnu
normal_libs =

foo: $(objects)
ifeq ($(CC),gcc)
    $(CC) -o foo $(objects) $(libs_for_gcc)
else
    $(CC) -o foo $(objects) $(normal_libs)
endif
```

在上面示例的规则中，目标 `foo` 可以根据变量 `$(CC)` 值来选取不同的函数库来编译程序。

 **`ifeq` 、 `else` 和 `endif` ：**

 `ifeq` 表示条件语句的开始，并指定一个条件表达式，表达式包含两个参数，以逗号分隔，表达式以圆括号括起。 `else` 表示条件表达式为假的情况。 `endif` 表示一个条件语句的结束，任何一个条件表达式都应该以 `endif` 结束。

#### b).语法

条件表达式的语法为:

```
<conditional-directive>
<text-if-true>
else
<text-if-false>
endif
```

其中 `<conditional-directive>` 表示条件关键字，共**4** 个：

**1.ifeq：**

```
ifeq (<arg1>, <arg2>)
ifeq '<arg1>' '<arg2>'
ifeq "<arg1>" "<arg2>"
ifeq "<arg1>" '<arg2>'
ifeq '<arg1>' "<arg2>"
```

比较参数 `arg1` 和 `arg2` 的值是否相同

**2.ifneq:**

和 `ifeq` 类似。

**3.ifdef:**

```
ifdef <variable-name>
```

如果变量 `<variable-name>` 的值非空，则表达式为真；反之，表达式为假。<variable-name>也可以是一个**函数的返回值**。ifdef 只是测试一个变量是否有值，其并不会把变量扩展到当前位置。

**4.ifndef:**

和 `ifdef` ，格式相同，意思相反。

#最好**不要**把自动化变量（如 `$@` 等）放入条件表达式中，因为**自动化变量是在运行时才有的**，make**不允许把整个条件语句分成两部分放在不同的文件中**。